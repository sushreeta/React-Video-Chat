<!DOCTYPE html>
<html>
  <head>
    <title>VideoChatApp</title>
    <style>
       {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        font: 13px Helvetica, Arial;
      }
      #localVideo {
        height: 50%;
        width: 50%;
      }
      #remoteVideo {
        height: 25%;
        width: 25%;
      }
      #input {
        padding: 3px;
        position: fixed;
        bottom: 0;
        width: 100%;
      }
      #message {
        border: 1;
        padding: 10px;
        width: 80%;
      }
      #send {
        width: 10%;
        background: rgb(130, 224, 255);
        border: none;
        padding: 10px;
      }
      #list {
        list-style-type: none;
        padding: 5px 10px;
      }
    </style> 
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
  </head>
  <body>
    <div id="videos">
      <video id="localVideo" autoplay muted playsinline></video>

      <video id="remoteVideo" autoplay playsinline></video>
    </div>
    <ul id="list"></ul>
    <div id="input">
      <input type="text" id="message" /><button id="send">Send</button>
    </div>
    
    <br />

    <script>
      let isChannelReady = false;
      let isInitiator = false;
      let isStarted = false;
      let localStream;
      let pc;
      let remoteStream;
      let turnReady;

      let clientId;
      let recieverId;
      const room = "Room1";

      const socket = io.connect();

      if (room !== "") {
        socket.emit("create or join", room);
      }

      socket.on("created", () => {
        isInitiator = true;
      });

      socket.on("full", room => {
        console.log("Room " + room + " is full");
      });

      socket.on("join", room => {
        console.log(" peer made a request to the room " + room);
        isChannelReady = true;
      });

      socket.on("joined", room => {
        console.log("joined" + room);
        isChannelReady = true;
      });

      socket.on("log", array => {
        console.log.apply(console, array);
      });

      const sendMessage = message => {
        console.log("Client sending message: ", message);
        socket.emit("message", message);
      };

      socket.on("message", message => {
        console.log("Client received message:", message);
        if (message === "got user media") {
          start();
        } else if (message.type === "offer") {
          if (!isInitiator && !isStarted) {
            start();
          }
          pc.setRemoteDescription(new RTCSessionDescription(message));
          doAnswer();
        } else if (message.type === "answer" && isStarted) {
          pc.setRemoteDescription(new RTCSessionDescription(message));
        } else if (message.type === "candidate" && isStarted) {
          const candidate = new RTCIceCandidate({
            sdpMLineIndex: message.label,
            candidate: message.candidate
          });
          pc.addIceCandidate(candidate);
        } else if (message === "bye" && isStarted) {
          handleRemoteHangup();
        }
      });

      document.getElementById("send").addEventListener("click", () => {
        socket.emit("event", {
          room: room,
          message: document.getElementById("message").value,
          name: "client1"
        });
      });
      const addLi = message => {
        const li = document.createElement("li");
        li.appendChild(document.createTextNode(message));
        document.getElementById("list").appendChild(li);
      };
      socket.on('event', addLi)

      const localVideo = document.querySelector("#localVideo");
      const remoteVideo = document.querySelector("#remoteVideo");

      const gotStream = stream => {
        console.log("Adding local stream.");
        localStream = stream;
        localVideo.srcObject = stream;
        sendMessage("got user media");
        if (isInitiator) {
          start();
        }
      };
      navigator.mediaDevices
        .getUserMedia({
          audio: true,
          video: true
        })
        .then(gotStream)
        .catch(e => {
          alert("error: " + e.name);
        });

      const constraints = {
        video: true
      };

      console.log("Getting user media with constraints", constraints);

      const start = () => {
        if (
          !isStarted &&
          typeof localStream !== "undefined" &&
          isChannelReady
        ) {
          createPeerConnection();
          pc.addStream(localStream);
          isStarted = true;
          console.log("isInitiator", isInitiator);
          if (isInitiator) {
            doCall();
          }
        }
      };

      window.onbeforeunload = () => {
        sendMessage("bye");
      };

      const createPeerConnection = () => {
        try {
          pc = new RTCPeerConnection(null);
          pc.onicecandidate = handleIceCandidate;
          pc.onaddstream = handleRemoteStreamAdded;
          pc.onremovestream = handleRemoteStreamRemoved;
          console.log("Created RTCPeerConnnection");
        } catch (e) {
          console.log("Failed to create PeerConnection " + e.message);
          alert("Cannot create RTCPeerConnection.");
          return;
        }
      };

      const handleIceCandidate = event => {
        if (event.candidate) {
          sendMessage({
            type: "candidate",
            label: event.candidate.sdpMLineIndex,
            id: event.candidate.sdpMid,
            candidate: event.candidate.candidate
          });
        } else {
          console.log("End of candidates.");
        }
      };

      const handleCreateOfferError = event => {
        console.log("createOffer() error: ", event);
      };

      const doCall = () => {
        console.log("Sending offer to peer");
        pc.createOffer(setLocalAndSendMessage, handleCreateOfferError);
      };

      const doAnswer = () => {
        console.log("Sending answer to peer.");
        pc.createAnswer().then(
          setLocalAndSendMessage,
          onCreateSessionDescriptionError
        );
      };

      const setLocalAndSendMessage = sessionDescription => {
        pc.setLocalDescription(sessionDescription);
        console.log(
          "setLocalAndSendMessage sending message",
          sessionDescription
        );
        sendMessage(sessionDescription);
      };

      const onCreateSessionDescriptionError = error => {
        console.log(
          "Failed to create session description: " + error.toString()
        );
      };

      const handleRemoteStreamAdded = event => {
        console.log("Remote stream added.");
        remoteStream = event.stream;
        remoteVideo.srcObject = remoteStream;
      };

      const handleRemoteStreamRemoved = event => {
        console.log("Remote stream removed. Event: ", event);
      };

      const hangup = () => {
        console.log("Hanging up.");
        stop();
        sendMessage("bye");
      };

      const handleRemoteHangup = () => {
        console.log("Session terminated.");
        stop();
        isInitiator = false;
      };

      const stop = () => {
        isStarted = false;
        pc.close();
        pc = null;
      };
    </script>
  </body>
</html>
